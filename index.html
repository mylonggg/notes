<!DOCTYPE html>
<html>
<head>
    <title>D1å›¾ç‰‡ä¸Šä¼ æµ‹è¯•</title>
    <style>
        body { font-family: Arial; padding: 20px; background: #f0f0f0; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 25px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h2 { color: #333; border-bottom: 2px solid #007acc; padding-bottom: 10px; }
        label { display: block; margin: 15px 0 5px; font-weight: bold; color: #555; }
        input, select, textarea { 
            width: 100%; 
            padding: 12px; 
            margin: 5px 0 15px; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
            box-sizing: border-box;
            font-size: 14px;
        }
        input:focus, select:focus {
            border-color: #007acc;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0,122,204,0.2);
        }
        .button-group { display: flex; gap: 10px; margin: 20px 0; }
        button { 
            padding: 12px 20px; 
            background: #007acc; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            font-size: 14px;
            flex: 1;
            transition: background 0.3s;
        }
        button:hover { background: #005a9e; }
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #545b62; }
        button.danger { background: #dc3545; }
        button.danger:hover { background: #c82333; }
        button.success { background: #28a745; }
        button.success:hover { background: #218838; }
        #log, #result { 
            margin: 20px 0; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 5px; 
            border-left: 4px solid #007acc;
            white-space: pre-wrap; 
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { border-left-color: #28a745 !important; background: #d4edda !important; }
        .error { border-left-color: #dc3545 !important; background: #f8d7da !important; }
        .warning { border-left-color: #ffc107 !important; background: #fff3cd !important; }
        .info { border-left-color: #17a2b8 !important; background: #d1ecf1 !important; }
        .preview { 
            margin: 20px 0; 
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .preview img { 
            max-width: 100%; 
            max-height: 300px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .log-entry { 
            margin: 5px 0; 
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .log-time { color: #6c757d; font-size: 11px; }
        .log-message { color: #333; }
        .log-error { color: #dc3545; }
        .log-success { color: #28a745; }
        .log-warning { color: #ffc107; }
        .log-info { color: #17a2b8; }
    </style>
</head>
<body>
    <div class="container">
        <h2>ğŸ“ D1å›¾ç‰‡ä¸Šä¼ æµ‹è¯•å·¥å…·</h2>
        
        <div class="config-section">
            <h3>âš™ï¸ é…ç½®è®¾ç½®</h3>
            <div>
                <label>Worker URL:</label>
                <input type="text" id="apiUrl" placeholder="https://your-worker.workers.dev" 
                       value="https://cloudnotes-d1-images.your-account.workers.dev">
            </div>
            
            <div>
                <label>Admin Key:</label>
                <input type="password" id="adminKey" placeholder="è¾“å…¥ADMIN_KEY">
            </div>
        </div>
        
        <div class="file-section">
            <h3>ğŸ“¤ æ–‡ä»¶ä¸Šä¼ </h3>
            <div>
                <label>é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ (æœ€å¤§2MB):</label>
                <input type="file" id="fileInput" accept="image/*">
                <small>æ”¯æŒ: JPEG, PNG, GIF, WebP</small>
            </div>
            
            <div class="button-group">
                <button onclick="testAllEndpoints()" class="success">ğŸ” æµ‹è¯•æ‰€æœ‰ç«¯ç‚¹</button>
                <button onclick="uploadImage()" class="primary">ğŸ“¤ ä¸Šä¼ å›¾ç‰‡</button>
            </div>
            
            <div class="button-group">
                <button onclick="testConnection()" class="secondary">ğŸ“¡ æµ‹è¯•è¿æ¥</button>
                <button onclick="testImageList()" class="secondary">ğŸ“‹ è·å–å›¾ç‰‡åˆ—è¡¨</button>
                <button onclick="initDatabase()" class="secondary">ğŸ—„ï¸ åˆå§‹åŒ–æ•°æ®åº“</button>
                <button onclick="clearLog()" class="danger">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
            </div>
        </div>
        
        <div class="preview" id="preview" style="display:none;">
            <h4>ğŸ–¼ï¸ å›¾ç‰‡é¢„è§ˆ:</h4>
            <img id="previewImg" src="" alt="é¢„è§ˆ">
            <p id="previewInfo"></p>
        </div>
        
        <div class="log-section">
            <h3>ğŸ“ å®æ—¶æ—¥å¿—</h3>
            <div id="log" class="info"></div>
        </div>
        
        <div class="result-section">
            <h3>ğŸ“Š ç»“æœè¾“å‡º</h3>
            <div id="result"></div>
        </div>
    </div>

    <script>
        let logContent = '';
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const icons = {
                error: 'âŒ',
                success: 'âœ…',
                warning: 'âš ï¸',
                info: 'â„¹ï¸'
            };
            const icon = icons[type] || 'ğŸ“';
            const logEntry = `
                <div class="log-entry">
                    <span class="log-time">[${timestamp}]</span>
                    <span class="log-${type} log-message">${icon} ${message}</span>
                </div>
            `;
            logContent += logEntry;
            document.getElementById('log').innerHTML = logContent;
            document.getElementById('log').scrollTop = document.getElementById('log').scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLog() {
            logContent = '';
            document.getElementById('log').innerHTML = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('result').className = '';
            document.getElementById('preview').style.display = 'none';
        }
        
        function showResult(message, type = 'info') {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `<pre>${message}</pre>`;
            resultDiv.className = type;
        }
        
        // è·å–åŸºç¡€é…ç½®
        function getConfig() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const adminKey = document.getElementById('adminKey').value.trim();
            
            if (!apiUrl || !adminKey) {
                throw new Error('è¯·å¡«å†™API URLå’ŒAdmin Key');
            }
            
            // ç¡®ä¿URLä»¥/ç»“å°¾
            const cleanApiUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
            
            return { apiUrl: cleanApiUrl, adminKey };
        }
        
        async function testConnection() {
            clearLog();
            try {
                const { apiUrl, adminKey } = getConfig();
                log(`æµ‹è¯•è¿æ¥åˆ°: ${apiUrl}`);
                
                // æµ‹è¯•å¥åº·æ£€æŸ¥
                log('æµ‹è¯• /api/health ç«¯ç‚¹...');
                const healthResponse = await fetch(`${apiUrl}/api/health`);
                const healthData = await healthResponse.json();
                log(`å¥åº·æ£€æŸ¥å“åº”: ${JSON.stringify(healthData)}`, 
                    healthResponse.ok ? 'success' : 'error');
                
                showResult(JSON.stringify(healthData, null, 2), 
                          healthResponse.ok ? 'success' : 'error');
                
            } catch (error) {
                log(`è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                showResult(`é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        async function initDatabase() {
            clearLog();
            try {
                const { apiUrl, adminKey } = getConfig();
                log(`åˆå§‹åŒ–D1æ•°æ®åº“...`);
                
                const response = await fetch(`${apiUrl}/api/images/init-db`, {
                    method: 'POST',
                    headers: { 
                        'Authorization': adminKey,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ`, 'success');
                    showResult(JSON.stringify(data, null, 2), 'success');
                } else {
                    log(`æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: ${data.error}`, 'error');
                    showResult(JSON.stringify(data, null, 2), 'error');
                }
                
            } catch (error) {
                log(`åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                showResult(`é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        async function testImageList() {
            clearLog();
            try {
                const { apiUrl, adminKey } = getConfig();
                log(`è·å–å›¾ç‰‡åˆ—è¡¨...`);
                
                const response = await fetch(`${apiUrl}/api/images/list`, {
                    method: 'GET',
                    headers: { 
                        'Authorization': adminKey,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.status === 401) {
                    log(`è®¤è¯å¤±è´¥: Admin Key é”™è¯¯`, 'error');
                    return;
                }
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = Array.isArray(data.data) ? data.data.length : 0;
                    log(`è·å–åˆ° ${count} å¼ å›¾ç‰‡`, 'success');
                    showResult(JSON.stringify(data, null, 2), 'success');
                    
                    // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ˜¾ç¤ºç¬¬ä¸€å¼ 
                    if (count > 0 && data.data[0].url) {
                        await testImageAccess(apiUrl, data.data[0].url);
                    }
                } else {
                    log(`è·å–å¤±è´¥: ${data.error}`, 'error');
                    showResult(JSON.stringify(data, null, 2), 'error');
                }
                
            } catch (error) {
                log(`è·å–å¤±è´¥: ${error.message}`, 'error');
                showResult(`é”™è¯¯: ${error.message}`, 'error');
            }
        }
        
        async function uploadImage() {
            clearLog();
            
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                return;
            }
            
            try {
                const { apiUrl, adminKey } = getConfig();
                
                log(`å¼€å§‹ä¸Šä¼ : ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);
                log(`æ–‡ä»¶ç±»å‹: ${file.type}`);
                
                // éªŒè¯æ–‡ä»¶å¤§å° (2MBé™åˆ¶)
                const maxSize = 2 * 1024 * 1024;
                if (file.size > maxSize) {
                    log(`æ–‡ä»¶è¿‡å¤§: è¶…è¿‡2MBé™åˆ¶ (D1é™åˆ¶)`, 'error');
                    showResult(`é”™è¯¯: æ–‡ä»¶è¶…è¿‡2MBé™åˆ¶`, 'error');
                    return;
                }
                
                // éªŒè¯æ–‡ä»¶ç±»å‹
                const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
                if (!allowedTypes.includes(file.type.toLowerCase())) {
                    log(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.type}`, 'error');
                    showResult(`é”™è¯¯: ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹`, 'error');
                    return;
                }
                
                // åˆ›å»ºFormData
                const formData = new FormData();
                formData.append('image', file);
                
                // æ˜¾ç¤ºè¯·æ±‚è¯¦ç»†ä¿¡æ¯
                log(`è¯·æ±‚URL: ${apiUrl}/api/images/upload`);
                log(`è¯·æ±‚æ–¹æ³•: POST`);
                log(`æˆæƒå¤´: ${adminKey ? 'å·²è®¾ç½®' : 'æœªè®¾ç½®'}`);
                
                // å‘é€è¯·æ±‚
                const startTime = Date.now();
                const response = await fetch(`${apiUrl}/api/images/upload`, {
                    method: 'POST',
                    headers: {
                        'Authorization': adminKey
                        // æ³¨æ„ï¼šä¸è¦è®¾ç½®Content-Typeï¼Œè®©æµè§ˆå™¨è‡ªåŠ¨è®¾ç½®multipart/form-data
                    },
                    body: formData
                });
                
                const endTime = Date.now();
                log(`è¯·æ±‚è€—æ—¶: ${endTime - startTime}ms`);
                log(`å“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);
                
                // è§£æå“åº”
                let data;
                try {
                    const text = await response.text();
                    log(`åŸå§‹å“åº”: ${text.substring(0, 500)}`, 'info');
                    data = JSON.parse(text);
                } catch (parseError) {
                    log(`å“åº”è§£æå¤±è´¥: ${parseError.message}`, 'error');
                    showResult(`è§£æé”™è¯¯: ${parseError.message}`, 'error');
                    return;
                }
                
                if (response.ok && data.success) {
                    log(`ä¸Šä¼ æˆåŠŸ! ID: ${data.data.id}`, 'success');
                    log(`æ–‡ä»¶å: ${data.data.filename}`, 'success');
                    log(`URL: ${apiUrl}${data.data.url}`, 'success');
                    
                    const displayInfo = {
                        çŠ¶æ€: 'âœ… ä¸Šä¼ æˆåŠŸ',
                        å›¾ç‰‡ID: data.data.id,
                        æ–‡ä»¶å: data.data.filename,
                        åŸå§‹æ–‡ä»¶å: data.data.originalName,
                        æ–‡ä»¶å¤§å°: `${(data.data.size / 1024).toFixed(2)} KB`,
                        å›¾ç‰‡URL: `${apiUrl}${data.data.url}`,
                        ç›´æ¥URL: `${apiUrl}${data.data.directUrl}`,
                        ä¸Šä¼ æ—¶é—´: new Date(data.data.uploadedAt).toLocaleString(),
                        å­˜å‚¨æ–¹å¼: 'D1æ•°æ®åº“ (Base64)',
                        å®Œæ•´å“åº”: data
                    };
                    
                    showResult(JSON.stringify(displayInfo, null, 2), 'success');
                    
                    // ç«‹å³æµ‹è¯•æŸ¥çœ‹å›¾ç‰‡
                    if (data.data.url) {
                        await testImageAccess(apiUrl, data.data.url);
                    }
                    
                } else {
                    log(`ä¸Šä¼ å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                    showResult(JSON.stringify(data, null, 2), 'error');
                }
                
            } catch (error) {
                log(`è¯·æ±‚å¼‚å¸¸: ${error.message}`, 'error');
                log(`å †æ ˆ: ${error.stack}`, 'error');
                showResult(`è¯·æ±‚å¼‚å¸¸: ${error.message}`, 'error');
            }
        }
        
        async function testImageAccess(apiUrl, imagePath) {
            log(`æµ‹è¯•å›¾ç‰‡è®¿é—®: ${apiUrl}${imagePath}`);
            
            try {
                const startTime = Date.now();
                const response = await fetch(`${apiUrl}${imagePath}`);
                const endTime = Date.now();
                
                if (response.ok) {
                    const contentType = response.headers.get('content-type');
                    const contentLength = response.headers.get('content-length');
                    
                    log(`âœ… å›¾ç‰‡è®¿é—®æˆåŠŸ (${endTime - startTime}ms)`, 'success');
                    log(`Content-Type: ${contentType}`, 'success');
                    log(`Content-Length: ${contentLength || 'æœªçŸ¥'} bytes`, 'success');
                    
                    // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
                    const blob = await response.blob();
                    if (blob.size > 0) {
                        const blobUrl = URL.createObjectURL(blob);
                        
                        document.getElementById('previewImg').src = blobUrl;
                        document.getElementById('previewInfo').innerHTML = 
                            `âœ… å›¾ç‰‡åŠ è½½æˆåŠŸ<br>
                             å¤§å°: ${blob.size} bytes<br>
                             ç±»å‹: ${blob.type}`;
                        document.getElementById('preview').style.display = 'block';
                        
                        log(`âœ… å›¾ç‰‡é¢„è§ˆæ˜¾ç¤ºæˆåŠŸ`, 'success');
                    } else {
                        log(`âŒ å›¾ç‰‡æ•°æ®ä¸ºç©º`, 'error');
                    }
                } else {
                    log(`âŒ å›¾ç‰‡è®¿é—®å¤±è´¥: ${response.status}`, 'error');
                }
            } catch (error) {
                log(`âŒ å›¾ç‰‡è®¿é—®å¼‚å¸¸: ${error.message}`, 'error');
            }
        }
        
        async function testAllEndpoints() {
            clearLog();
            const { apiUrl, adminKey } = getConfig();
            
            log('ğŸš€ å¼€å§‹æµ‹è¯•æ‰€æœ‰APIç«¯ç‚¹...');
            
            const endpoints = [
                { name: 'å¥åº·æ£€æŸ¥', method: 'GET', path: '/api/health', needsAuth: false },
                { name: 'åˆå§‹åŒ–æ•°æ®åº“', method: 'POST', path: '/api/images/init-db', needsAuth: true },
                { name: 'è·å–å›¾ç‰‡åˆ—è¡¨', method: 'GET', path: '/api/images/list', needsAuth: true }
            ];
            
            for (const endpoint of endpoints) {
                log(`æµ‹è¯•: ${endpoint.name} (${endpoint.method} ${endpoint.path})`);
                
                try {
                    const headers = {
                        'Content-Type': 'application/json'
                    };
                    
                    if (endpoint.needsAuth) {
                        headers['Authorization'] = adminKey;
                    }
                    
                    const response = await fetch(`${apiUrl}${endpoint.path}`, {
                        method: endpoint.method,
                        headers: headers
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        log(`âœ… ${endpoint.name}: æˆåŠŸ`, 'success');
                    } else {
                        log(`âŒ ${endpoint.name}: å¤±è´¥ - ${data.error}`, 'error');
                    }
                    
                } catch (error) {
                    log(`âŒ ${endpoint.name}: é”™è¯¯ - ${error.message}`, 'error');
                }
            }
            
            log('ğŸ“Š æ‰€æœ‰ç«¯ç‚¹æµ‹è¯•å®Œæˆ');
        }
        
        // è‡ªåŠ¨ä¿å­˜å’ŒåŠ è½½é…ç½®
        document.addEventListener('DOMContentLoaded', () => {
            const savedApiUrl = localStorage.getItem('cloudnotes_api_url');
            const savedAdminKey = localStorage.getItem('cloudnotes_admin_key');
            
            if (savedApiUrl) {
                document.getElementById('apiUrl').value = savedApiUrl;
            }
            if (savedAdminKey) {
                document.getElementById('adminKey').value = savedAdminKey;
            }
            
            // ä¿å­˜é…ç½®
            document.getElementById('apiUrl').addEventListener('change', function() {
                localStorage.setItem('cloudnotes_api_url', this.value);
            });
            
            document.getElementById('adminKey').addEventListener('change', function() {
                localStorage.setItem('cloudnotes_admin_key', this.value);
            });
            
            // æ·»åŠ æ‹–æ”¾ä¸Šä¼ åŠŸèƒ½
            const dropZone = document.querySelector('.file-section');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.backgroundColor = '#e9ecef';
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.style.backgroundColor = '';
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.backgroundColor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    document.getElementById('fileInput').files = files;
                    log(`ğŸ“ å·²é€‰æ‹©æ–‡ä»¶: ${files[0].name}`, 'success');
                }
            });
            
            log('ğŸŸ¢ æµ‹è¯•å·¥å…·å·²å°±ç»ªï¼Œè¯·å…ˆæµ‹è¯•è¿æ¥', 'info');
        });
    </script>
</body>
</html>
